<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: transparent;
            touch-action: none;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%;
        }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script>
        let scene, camera, renderer, dice;
        let isRolling = false;
        let diceSides = {{DICE_SIDES}};
        
        function init(sides) {
            if (sides) diceSides = sides;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            createDice(diceSides);
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function createDice(sides) {
            if (dice) scene.remove(dice);
            
            let geometry;
            if (sides === 4) {
                geometry = new THREE.TetrahedronGeometry(1.5);
            } else if (sides === 6) {
                geometry = new THREE.BoxGeometry(2, 2, 2);
            } else if (sides === 8) {
                geometry = new THREE.OctahedronGeometry(1.5);
            } else if (sides === 10) {
                geometry = new THREE.ConeGeometry(1.2, 2.4, 5);
            } else if (sides === 12) {
                geometry = new THREE.DodecahedronGeometry(1.5);
            } else if (sides === 20) {
                geometry = new THREE.IcosahedronGeometry(1.5);
            } else {
                geometry = new THREE.IcosahedronGeometry(1.5);
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: 0x4169E1,
                metalness: 0.3,
                roughness: 0.4,
                transparent: true,
                opacity: 0.95
            });
            
            dice = new THREE.Mesh(geometry, material);
            scene.add(dice);
        }
        
        function startDiceRoll(number) {
            if (isRolling) return;
            isRolling = true;
            
            const rotations = 3 + Math.random() * 2;
            const duration = 1500;
            const startTime = Date.now();
            
            function roll() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeOut = 1 - Math.pow(1 - progress, 3);
                
                dice.rotation.x = rotations * Math.PI * 2 * easeOut;
                dice.rotation.y = rotations * Math.PI * 2 * easeOut * 1.3;
                dice.rotation.z = rotations * Math.PI * 2 * easeOut * 0.7;
                
                if (progress < 1) {
                    requestAnimationFrame(roll);
                } else {
                    isRolling = false;
                    showNumber(number);
                    window.webkit.messageHandlers.diceRollComplete.postMessage(number);
                }
            }
            
            roll();
        }
        
        function showNumber(number) {
            const angle = (number / diceSides) * Math.PI * 2;
            dice.rotation.set(angle, angle * 0.7, angle * 1.3);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isRolling) {
                dice.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
